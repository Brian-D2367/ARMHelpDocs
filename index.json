{
  "docs/Articles/Armoury/armoury.html": {
    "href": "docs/Articles/Armoury/armoury.html",
    "title": "Armoury | ARMalytics",
    "keywords": "Armoury Markdown Markdown is a lightweight markup language with plain text formatting syntax. Docfx supports CommonMark compliant Markdown parsed through the Markdig parsing engine. Markdown Extensions Docfx supports additional markdown syntax that provide richer content. These syntax are specific to docfx and won't be rendered elsewhere like GitHub. In addition to its own extensions, docfx also supports the use of the markdown extensions provided by Markdig. The following list of Markdig extensions are enabled by default for docfx: Mathematics Emphasis Extras Auto Identifiers Media Links Pipe Tables Auto Links Emoji To use other custom markdown extensions: Use docfx as a NuGet library: <PackageReference Include=\"Docfx.App\" Version=\"2.70.0\" /> Configure the markdig markdown pipeline: var options = new BuildOptions { // Enable custom markdown extensions here ConfigureMarkdig = pipeline => pipeline.UseAbbreviations().UseFootnotes(), } await Docset.Build(\"docfx.json\", options); Alternatively, set the build.markdownEngineProperties.markdigExtensions property in docfx.json to the list of additional extensions to use: { \"build\": { \"markdownEngineProperties\": { \"markdigExtensions\": [ \"Abbreviations\", \"Footnotes\" ] } } } The known extension names are listed in MardownExtensions.Configure method in the MarkDig project. Note The custom configuration of extensions via the build.markdownEngineProperties.markdigExtensions property is not supported. YAML header Also referred to as YAML Front Matter, the YAML header is used to annotate a Markdown file with various metadata elements. It should appear at the top of the document. Here's an example: --- uid: fileA --- # This is fileA ... In this example, the UID provides a unique identifier for the file and is intended to be unique inside a project. If you define duplicate UID for two files, the resolve result is undetermined. For API reference files, the UID is auto generated by mangling the API's signature. For example, the System.String class's UID is System.String. You can open a generated YAML file to lookup the value of its UID. Note Conceptual Markdown file doesn't have UID generated by default. So it cannot be cross referenced unless you give it a UID. See the list of predefined metadata for applicable options for inclusion in the YAML header. Alerts Alerts are block quotes that render with colors and icons that indicate the significance of the content. The following alert types are supported: > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. > [!IMPORTANT] > Essential information required for user success. > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. They look like this in rendered page: Note Information the user should notice even if skimming. Tip Optional information to help a user be more successful. Important Essential information required for user success. Caution Negative potential consequences of an action. Warning Dangerous certain consequences of an action. Custom Alerts You can define custom alerts with the build.markdownEngineProperties.alerts property in docfx.json and use it in markdown files. The key specifies the markdown keyword without the surrounding [!, ] symbols. The value is the CSS class names: { \"build\": { \"markdownEngineProperties\": { \"alerts\": { \"TODO\": \"alert alert-secondary\" } } } } > [!TODO] > This is a custom TODO section The above custom alert looks like this in rendered page: [!TODO] This is a custom TODO section DocFX allows you to customize the display of alert titles in your documentation. By default, alert titles are displayed as the keyword in upper case. To change this behavior, you can create a custom template and use a token.json file to define your custom alert titles: Create a custom template: Follow the steps in the [Custom Template Guide](create a custom template) to create your own template. Create a token.json file: In your custom template folder, create a new file named token.json. This file will be used to define your custom alert titles. The format should be as follows: { \"todo\": \"MY TODO\" } In this example, the key is the alert keyword in lower case (e.g., \"todo\"), and the value is the custom display title of the alert (e.g., \"MY TODO\"). Video You can embed a video in your page by using the following Markdown syntax: > [!Video embed_link] Example: > [!Video https://www.youtube.com/embed/Sz1lCeedcPI] This will be rendered as: Image You can embed a image in your page by using the following Markdown syntax: ![ <alt-text> ]( <image-link> ) Example: ![alt-text](https://learn.microsoft.com/en-us/media/learn/not-found/learn-not-found-light-mode.png?branch=main) This will be rendered as: Math Expressions Docfx supports LaTeX formatted math expressions within markdown using MathJax. Note Math expressions is only supported in the modern template. To include a math expression inline with your text, delimit the expression with a dollar symbol $. This sentence uses `$` delimiters to show math inline: $\\sqrt{3x-1}+(1+x)^2$ This sentence uses $ delimiters to show math inline: \\(\\sqrt{3x-1}+(1+x)^2\\) To add a math expression as a block, start a new line and delimit the expression with two dollar symbols $$. **The Cauchy-Schwarz Inequality** $$\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)$$ The Cauchy-Schwarz Inequality \\(\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)\\) Mermaid Diagrams You can embed mermaid diagrams using markdown code block: Example: ```mermaid flowchart LR A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] ``` This will be rendered as: flowchart LR A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] Note Mermaid diagrams is only supported in the modern template. There are plenty of other diagrams supported by mermaid such as: Pie chart pie \"Dogs\" : 386 \"Cats\" : 85.9 \"Rats\" : 15 Bar chart gantt title Git Issues - days since last update dateFormat X axisFormat %s section Issue19062 71 : 0, 71 section Issue19401 36 : 0, 36 section Issue193 34 : 0, 34 section Issue7441 9 : 0, 9 section Issue1300 5 : 0, 5 User Journey diagram journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me Class diagram classDiagram Class01 <|-- AveryLongClass : Cool <<Interface>> Class01 Class09 --> C2 : Where am I? Class09 --* C3 Class09 --|> Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { <<service>> int id size() } PlantUML Diagrams You can embed PlantUML diagrams using markdown code blocks: Example: ```plantuml Bob -> Alice : hello ``` This will be rendered as: There are plenty of other diagrams supported by PlantUML such as: Sequence diagram Use Case diagram Class diagram Activity diagram Component diagram State diagram Gantt diagram Deployment diagram Mindmap diagram Refer to the PlantUml reference guide for more details. Settings The PlantUML extension can be configured using the build.markdownEngineProperties.plantUml property of your docfx.json file: { \"build\": { \"markdownEngineProperties\": { \"plantUml\": { \"outputFormat\": \"svg\", \"remoteUrl\": \"http://www.plantuml.com/plantuml/\", \"renderingMode\": \"remote\" } } } } The following settings are available for configuration: Setting Description Default javaPath path to java installation uses the JAVA_HOME environment variable localGraphvizDotPath path to graphviz dot exe (required for local rendering mode only) none localPlantUmlPath path to plantuml.jar will look in project directory outputFormat format of generated images (svg, ascii, ascii_unicode) svg remoteUrl url to remote PlantUml server (required for remote rendering mode only) http://www.plantuml.com/plantuml/ renderingMode remote or local remote Local Rendering By default, PlantUML diagrams will be rendered on the remote server. Local rendering mode uses a local copy of PlantUML to render diagrams. Local rendering mode can be configured in your docfx.json file: { \"build\": { \"markdownEngineProperties\": { \"plantUml\": { \"localPlantUmlPath\": \"path/to/plantuml.jar\", \"renderingMode\": \"local\" } } } } Note GraphViz Dot is required for local rendering mode of any diagram other than sequence. Refer to the PlantUML documentation for more detailed instructions. Include Markdown Files Where markdown files need to be repeated in multiple articles, you can use an include file. The includes feature replace the reference with the contents of the included file at build time. You can reuse a common text snippet within a sentence using inline include: Text before [!INCLUDE [<title>](<filepath>)] and after. Or reuse an entire Markdown file as a block, nested within a section of an article. Block include is on its own line: [!INCLUDE [<title>](<filepath>)] Where <title> is the name of the file and <filepath> is the relative path to the file. Example: [!INCLUDE [my-markdown-block](../../includes/my-markdown-block.md)] Included markdown files needs to be excluded from build, they are usually placed in the /includes folder. Code Snippet There are several ways to include code in an article. The code snippet syntax replaces code from another file: [!code-csharp[](Program.cs)] You can include selected lines from the code snippet using region or line range syntax: [!code-csharp[](Program.cs#region)] [!code-csharp[](Program.cs#L12-L16)] Code snippets are indicated by using a specific link syntax described as follows: [!code-<language>[](<filepath><query-options>)] Where <language> is the syntax highlighting language of the code and <filepath> is the relative path to the markdown file. Highlight Selected Lines Code Snippets typically include more code than necessary in order to provide context. It helps readability when you highlight the key lines that you're focusing on. To highlight key lines, use the highlight query options: [!code-csharp[](Program.cs?highlight=2,5-7,9-)] The example highlights lines 2, line 5 to 7 and lines 9 to the end of the file. Warning It looks like the sample you are looking for does not exist. Tabs Tabs enable content that is multi-faceted. They allow sections of a document to contain variant content renderings and eliminates duplicate content. Here's an example of the tab experience: Linux Windows Content for Linux... Content for Windows... The above tab group was created with the following syntax: # [Linux](#tab/linux) Content for Linux... # [Windows](#tab/windows) Content for Windows... --- Tabs are indicated by using a specific link syntax within a Markdown header. The syntax can be described as follows: # [Tab Display Name](#tab/tab-id) A tab starts with a Markdown header, #, and is followed by a Markdown link [](). The text of the link will become the text of the tab header, displayed to the customer. In order for the header to be recognized as a tab, the link itself must start with #tab/ and be followed by an ID representing the content of the tab. The ID is used to sync all same-ID tabs across the page. Using the above example, when a user selects a tab with the link #tab/windows, all tabs with the link #tab/windows on the page will be selected. Dependent tabs It's possible to make the selection in one set of tabs dependent on the selection in another set of tabs. Here's an example of that in action: .NET .NET TypeScript TypeScript REST API .NET content for Linux... .NET content for Windows... TypeScript content for Linux... TypeScript content for Windows... REST API content, independent of platform... Notice how changing the Linux/Windows selection above changes the content in the .NET and TypeScript tabs. This is because the tab group defines two versions for each .NET and TypeScript, where the Windows/Linux selection above determines which version is shown for .NET/TypeScript. Here's the markup that shows how this is done: # [.NET](#tab/dotnet/linux) .NET content for Linux... # [.NET](#tab/dotnet/windows) .NET content for Windows... # [TypeScript](#tab/typescript/linux) TypeScript content for Linux... # [TypeScript](#tab/typescript/windows) TypeScript content for Windows... # [REST API](#tab/rest) REST API content, independent of platform... --- Differences introduced by DFM syntax Warning Please note that DFM introduces more syntax to support more functionalities. When GFM does not support them, preview the Markdown file inside GFM Preview can lead to different results. Text after block extension Some block extension in DFM cannot be recognized in GFM. In GFM, it would be treated as a part of paragraph. Then, following content would be treated as a part of paragraph. For example: > [!NOTE] > This is code. In GFM, it will be rendered as a paragraph with content [!NOTE] This is code. in blockquote. In DFM, it will be rendered as a code in note."
  },
  "docs/Articles/DigitAll/digitAll.html": {
    "href": "docs/Articles/DigitAll/digitAll.html",
    "title": "DigitAll | ARMalytics",
    "keywords": "DigitAll DigitAll is a powerful feature designed to help you identify and track important items in the Armoury Vault. Whether you're using barcodes, RFID, or visual detection, DigitAll ensures you always know the exact location of your equipment. Features: Barcode Scanning: Effortlessly scan barcodes to keep track of your items. RFID Tracking: Utilize RFID technology for real-time item tracking. Visual Detection: Use advanced image recognition to automatically identify items. Benefits: Increased Efficiency: Quickly locate your items with minimal effort. Real-Time Updates: Get instant notifications when an item moves or is accessed. Security: Ensure that only authorized personnel can access sensitive equipment. Usage: Open the DigitAll tool in the Armoury Vault. Select the scanning method: Barcode, RFID, or Visual. Scan the item or use the visual detection system to identify and track your equipment. Receive real-time updates and alerts. Lorem Ipsum: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin ac neque nulla. Sed luctus orci vitae nisl aliquet, nec feugiat elit efficitur. Nam auctor tristique tortor, et vulputate erat aliquet in. Integer tempor orci nisi, at gravida dui malesuada non. Mauris ut purus ut lorem tincidunt varius. Cras condimentum libero et suscipit vulputate. Nam ultricies velit sit amet felis volutpat gravida. Ut sit amet tortor viverra, rhoncus felis eu, malesuada eros. Integer eget dui ac sapien vehicula gravida ac in eros. Video You can embed a video in your page by using the following Markdown syntax: > [!Video embed_link] Example: > [!Video https://www.youtube.com/embed/Sz1lCeedcPI] This will be rendered as: Your browser does not support the video tag. Image You can embed a image in your page by using the following Markdown syntax: ![ <alt-text> ]( <image-link> ) Example: ![alt-text](https://learn.microsoft.com/en-us/media/learn/not-found/learn-not-found-light-mode.png?branch=main) This will be rendered as:"
  },
  "docs/Articles/Enemy/enemy.html": {
    "href": "docs/Articles/Enemy/enemy.html",
    "title": "Enemy | ARMalytics",
    "keywords": "Enemy Markdown Markdown is a lightweight markup language with plain text formatting syntax. Docfx supports CommonMark compliant Markdown parsed through the Markdig parsing engine. Markdown Extensions Docfx supports additional markdown syntax that provide richer content. These syntax are specific to docfx and won't be rendered elsewhere like GitHub. In addition to its own extensions, docfx also supports the use of the markdown extensions provided by Markdig. The following list of Markdig extensions are enabled by default for docfx: Mathematics Emphasis Extras Auto Identifiers Media Links Pipe Tables Auto Links Emoji To use other custom markdown extensions: Use docfx as a NuGet library: <PackageReference Include=\"Docfx.App\" Version=\"2.70.0\" /> Configure the markdig markdown pipeline: var options = new BuildOptions { // Enable custom markdown extensions here ConfigureMarkdig = pipeline => pipeline.UseAbbreviations().UseFootnotes(), } await Docset.Build(\"docfx.json\", options); Alternatively, set the build.markdownEngineProperties.markdigExtensions property in docfx.json to the list of additional extensions to use: { \"build\": { \"markdownEngineProperties\": { \"markdigExtensions\": [ \"Abbreviations\", \"Footnotes\" ] } } } The known extension names are listed in MardownExtensions.Configure method in the MarkDig project. Note The custom configuration of extensions via the build.markdownEngineProperties.markdigExtensions property is not supported. YAML header Also referred to as YAML Front Matter, the YAML header is used to annotate a Markdown file with various metadata elements. It should appear at the top of the document. Here's an example: --- uid: fileA --- # This is fileA ... In this example, the UID provides a unique identifier for the file and is intended to be unique inside a project. If you define duplicate UID for two files, the resolve result is undetermined. For API reference files, the UID is auto generated by mangling the API's signature. For example, the System.String class's UID is System.String. You can open a generated YAML file to lookup the value of its UID. Note Conceptual Markdown file doesn't have UID generated by default. So it cannot be cross referenced unless you give it a UID. See the list of predefined metadata for applicable options for inclusion in the YAML header. Alerts Alerts are block quotes that render with colors and icons that indicate the significance of the content. The following alert types are supported: > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. > [!IMPORTANT] > Essential information required for user success. > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. They look like this in rendered page: Note Information the user should notice even if skimming. Tip Optional information to help a user be more successful. Important Essential information required for user success. Caution Negative potential consequences of an action. Warning Dangerous certain consequences of an action. Custom Alerts You can define custom alerts with the build.markdownEngineProperties.alerts property in docfx.json and use it in markdown files. The key specifies the markdown keyword without the surrounding [!, ] symbols. The value is the CSS class names: { \"build\": { \"markdownEngineProperties\": { \"alerts\": { \"TODO\": \"alert alert-secondary\" } } } } > [!TODO] > This is a custom TODO section The above custom alert looks like this in rendered page: [!TODO] This is a custom TODO section DocFX allows you to customize the display of alert titles in your documentation. By default, alert titles are displayed as the keyword in upper case. To change this behavior, you can create a custom template and use a token.json file to define your custom alert titles: Create a custom template: Follow the steps in the [Custom Template Guide](create a custom template) to create your own template. Create a token.json file: In your custom template folder, create a new file named token.json. This file will be used to define your custom alert titles. The format should be as follows: { \"todo\": \"MY TODO\" } In this example, the key is the alert keyword in lower case (e.g., \"todo\"), and the value is the custom display title of the alert (e.g., \"MY TODO\"). Video You can embed a video in your page by using the following Markdown syntax: > [!Video embed_link] Example: > [!Video https://www.youtube.com/embed/Sz1lCeedcPI] This will be rendered as: Image You can embed a image in your page by using the following Markdown syntax: ![ <alt-text> ]( <image-link> ) Example: ![alt-text](https://learn.microsoft.com/en-us/media/learn/not-found/learn-not-found-light-mode.png?branch=main) This will be rendered as: Math Expressions Docfx supports LaTeX formatted math expressions within markdown using MathJax. Note Math expressions is only supported in the modern template. To include a math expression inline with your text, delimit the expression with a dollar symbol $. This sentence uses `$` delimiters to show math inline: $\\sqrt{3x-1}+(1+x)^2$ This sentence uses $ delimiters to show math inline: \\(\\sqrt{3x-1}+(1+x)^2\\) To add a math expression as a block, start a new line and delimit the expression with two dollar symbols $$. **The Cauchy-Schwarz Inequality** $$\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)$$ The Cauchy-Schwarz Inequality \\(\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)\\) Mermaid Diagrams You can embed mermaid diagrams using markdown code block: Example: ```mermaid flowchart LR A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] ``` This will be rendered as: flowchart LR A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] Note Mermaid diagrams is only supported in the modern template. There are plenty of other diagrams supported by mermaid such as: Pie chart pie \"Dogs\" : 386 \"Cats\" : 85.9 \"Rats\" : 15 Bar chart gantt title Git Issues - days since last update dateFormat X axisFormat %s section Issue19062 71 : 0, 71 section Issue19401 36 : 0, 36 section Issue193 34 : 0, 34 section Issue7441 9 : 0, 9 section Issue1300 5 : 0, 5 User Journey diagram journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 3: Me Class diagram classDiagram Class01 <|-- AveryLongClass : Cool <<Interface>> Class01 Class09 --> C2 : Where am I? Class09 --* C3 Class09 --|> Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { <<service>> int id size() } PlantUML Diagrams You can embed PlantUML diagrams using markdown code blocks: Example: ```plantuml Bob -> Alice : hello ``` This will be rendered as: There are plenty of other diagrams supported by PlantUML such as: Sequence diagram Use Case diagram Class diagram Activity diagram Component diagram State diagram Gantt diagram Deployment diagram Mindmap diagram Refer to the PlantUml reference guide for more details. Settings The PlantUML extension can be configured using the build.markdownEngineProperties.plantUml property of your docfx.json file: { \"build\": { \"markdownEngineProperties\": { \"plantUml\": { \"outputFormat\": \"svg\", \"remoteUrl\": \"http://www.plantuml.com/plantuml/\", \"renderingMode\": \"remote\" } } } } The following settings are available for configuration: Setting Description Default javaPath path to java installation uses the JAVA_HOME environment variable localGraphvizDotPath path to graphviz dot exe (required for local rendering mode only) none localPlantUmlPath path to plantuml.jar will look in project directory outputFormat format of generated images (svg, ascii, ascii_unicode) svg remoteUrl url to remote PlantUml server (required for remote rendering mode only) http://www.plantuml.com/plantuml/ renderingMode remote or local remote Local Rendering By default, PlantUML diagrams will be rendered on the remote server. Local rendering mode uses a local copy of PlantUML to render diagrams. Local rendering mode can be configured in your docfx.json file: { \"build\": { \"markdownEngineProperties\": { \"plantUml\": { \"localPlantUmlPath\": \"path/to/plantuml.jar\", \"renderingMode\": \"local\" } } } } Note GraphViz Dot is required for local rendering mode of any diagram other than sequence. Refer to the PlantUML documentation for more detailed instructions. Include Markdown Files Where markdown files need to be repeated in multiple articles, you can use an include file. The includes feature replace the reference with the contents of the included file at build time. You can reuse a common text snippet within a sentence using inline include: Text before [!INCLUDE [<title>](<filepath>)] and after. Or reuse an entire Markdown file as a block, nested within a section of an article. Block include is on its own line: [!INCLUDE [<title>](<filepath>)] Where <title> is the name of the file and <filepath> is the relative path to the file. Example: [!INCLUDE [my-markdown-block](../../includes/my-markdown-block.md)] Included markdown files needs to be excluded from build, they are usually placed in the /includes folder. Code Snippet There are several ways to include code in an article. The code snippet syntax replaces code from another file: [!code-csharp[](Program.cs)] You can include selected lines from the code snippet using region or line range syntax: [!code-csharp[](Program.cs#region)] [!code-csharp[](Program.cs#L12-L16)] Code snippets are indicated by using a specific link syntax described as follows: [!code-<language>[](<filepath><query-options>)] Where <language> is the syntax highlighting language of the code and <filepath> is the relative path to the markdown file. Highlight Selected Lines Code Snippets typically include more code than necessary in order to provide context. It helps readability when you highlight the key lines that you're focusing on. To highlight key lines, use the highlight query options: [!code-csharp[](Program.cs?highlight=2,5-7,9-)] The example highlights lines 2, line 5 to 7 and lines 9 to the end of the file. Warning It looks like the sample you are looking for does not exist. Tabs Tabs enable content that is multi-faceted. They allow sections of a document to contain variant content renderings and eliminates duplicate content. Here's an example of the tab experience: Linux Windows Content for Linux... Content for Windows... The above tab group was created with the following syntax: # [Linux](#tab/linux) Content for Linux... # [Windows](#tab/windows) Content for Windows... --- Tabs are indicated by using a specific link syntax within a Markdown header. The syntax can be described as follows: # [Tab Display Name](#tab/tab-id) A tab starts with a Markdown header, #, and is followed by a Markdown link [](). The text of the link will become the text of the tab header, displayed to the customer. In order for the header to be recognized as a tab, the link itself must start with #tab/ and be followed by an ID representing the content of the tab. The ID is used to sync all same-ID tabs across the page. Using the above example, when a user selects a tab with the link #tab/windows, all tabs with the link #tab/windows on the page will be selected. Dependent tabs It's possible to make the selection in one set of tabs dependent on the selection in another set of tabs. Here's an example of that in action: .NET .NET TypeScript TypeScript REST API .NET content for Linux... .NET content for Windows... TypeScript content for Linux... TypeScript content for Windows... REST API content, independent of platform... Notice how changing the Linux/Windows selection above changes the content in the .NET and TypeScript tabs. This is because the tab group defines two versions for each .NET and TypeScript, where the Windows/Linux selection above determines which version is shown for .NET/TypeScript. Here's the markup that shows how this is done: # [.NET](#tab/dotnet/linux) .NET content for Linux... # [.NET](#tab/dotnet/windows) .NET content for Windows... # [TypeScript](#tab/typescript/linux) TypeScript content for Linux... # [TypeScript](#tab/typescript/windows) TypeScript content for Windows... # [REST API](#tab/rest) REST API content, independent of platform... --- Differences introduced by DFM syntax Warning Please note that DFM introduces more syntax to support more functionalities. When GFM does not support them, preview the Markdown file inside GFM Preview can lead to different results. Text after block extension Some block extension in DFM cannot be recognized in GFM. In GFM, it would be treated as a part of paragraph. Then, following content would be treated as a part of paragraph. For example: > [!NOTE] > This is code. In GFM, it will be rendered as a paragraph with content [!NOTE] This is code. in blockquote. In DFM, it will be rendered as a code in note.s"
  },
  "docs/Articles/Pulse/pulse.html": {
    "href": "docs/Articles/Pulse/pulse.html",
    "title": "Pulse | ARMalytics",
    "keywords": "Pulse"
  },
  "docs/Articles/RAPS/Campaign Maintenance/campaignMaintenance.html": {
    "href": "docs/Articles/RAPS/Campaign Maintenance/campaignMaintenance.html",
    "title": "RAPS Campus Maintenance | ARMalytics",
    "keywords": "RAPS Campus Maintenance"
  },
  "docs/Articles/RAPS/Dashboard/dashboard.html": {
    "href": "docs/Articles/RAPS/Dashboard/dashboard.html",
    "title": "RAPS Dashboard | ARMalytics",
    "keywords": "RAPS Dashboard"
  },
  "docs/Articles/RAPS/Import/Auto Film Number/autofilmnumber.html": {
    "href": "docs/Articles/RAPS/Import/Auto Film Number/autofilmnumber.html",
    "title": "RAPS Auto Import Film Number | ARMalytics",
    "keywords": "RAPS Auto Import Film Number"
  },
  "docs/Articles/RAPS/Import/RAPS Reporting/rapsreporting.html": {
    "href": "docs/Articles/RAPS/Import/RAPS Reporting/rapsreporting.html",
    "title": "RAPS Reporting | ARMalytics",
    "keywords": "RAPS Reporting"
  },
  "docs/Articles/RAPS/Import/Screens Summary/screensSummary.html": {
    "href": "docs/Articles/RAPS/Import/Screens Summary/screensSummary.html",
    "title": "RAPS Screens Summary | ARMalytics",
    "keywords": "RAPS Screens Summary"
  },
  "docs/Articles/RAPS/Import/import.html": {
    "href": "docs/Articles/RAPS/Import/import.html",
    "title": "RAPS Import | ARMalytics",
    "keywords": "RAPS Import"
  },
  "docs/Articles/RAPS/Message Alerts/messagealerts.html": {
    "href": "docs/Articles/RAPS/Message Alerts/messagealerts.html",
    "title": "RAPS Message Alerts | ARMalytics",
    "keywords": "RAPS Message Alerts"
  },
  "docs/Articles/RAPS/Reports/reports.html": {
    "href": "docs/Articles/RAPS/Reports/reports.html",
    "title": "RAPS Reports | ARMalytics",
    "keywords": "RAPS Reports Title Header (H1 header) Introduction (H3 header) This is some placeholder text to show examples of Markdown formatting. We have a full article template you can use when writing a DigitalOcean article. Please refer to our style and formatting guidelines for more detailed explanations: https://do.co/style Test Prerequisites (H2 header) Before you begin this guide you'll need the following: Familiarity with Markdown Step 1 ï¿½ Basic Markdown This is italics, this is bold, this is underline, and this is strikethrough. This is a list item. This list is unordered. This is a list item. This list is ordered. This is a quote. This is a quote inside a quote. This is a list in a quote. Another item in the quote list. We also support some extra syntax for setting the width, height and alignment of images. You can provide pixels (200/200px), or a percentage (50%), for the width/height. The alignment can be either left or right, with images being centered by default. These settings are all optional. { width=200 height=131 align=left } Use horizontal rules to break up long sections:"
  },
  "docs/Articles/RAPS/raps.html": {
    "href": "docs/Articles/RAPS/raps.html",
    "title": "RAPS | ARMalytics",
    "keywords": "RAPS This is a custom TODO section DocFX allows you to customize the display of alert titles in your documentation. By default, alert titles are displayed as the keyword in upper case. To change this behavior, you can create a custom template and use a token.json file to define your custom alert titles: Create a custom template: Follow the steps in the [Custom Template Guide](create a custom template) to create your own template. Create a token.json file: In your custom template folder, create a new file named token.json. This file will be used to define your custom alert titles. The format should be as follows: { \"todo\": \"MY TODO\" } In this example, the key is the alert keyword in lower case (e.g., \"todo\"), and the value is the custom display title of the alert (e.g., \"MY TODO\"). Video You can embed a video in your page by using the following Markdown syntax: > [!Video embed_link] Example: > [!Video https://www.youtube.com/embed/Sz1lCeedcPI] This will be rendered as: Image You can embed a image in your page by using the following Markdown syntax: ![ <alt-text> ]( <image-link> ) Example: ![alt-text](https://learn.microsoft.com/en-us/media/learn/not-found/learn-not-found-light-mode.png?branch=main) This will be rendered as: Math Expressions Docfx supports LaTeX formatted math expressions within markdown using MathJax. Note Math expressions is only supported in the modern template. To include a math expression inline with your text, delimit the expression with a dollar symbol $. This sentence uses `$` delimiters to show math inline: $\\sqrt{3x-1}+(1+x)^2$ This sentence uses $ delimiters to show math inline: \\(\\sqrt{3x-1}+(1+x)^2\\) To add a math expression as a block, start a new line and delimit the expression with two dollar symbols $$. **The Cauchy-Schwarz Inequality** $$\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)$$ The Cauchy-Schwarz Inequality \\(\\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right)\\)"
  },
  "docs/Articles/Spotter/spotter.html": {
    "href": "docs/Articles/Spotter/spotter.html",
    "title": "Spotter | ARMalytics",
    "keywords": "Spotter"
  },
  "docs/Articles/Sys Admin/sysadmin.html": {
    "href": "docs/Articles/Sys Admin/sysadmin.html",
    "title": "Sys Admin | ARMalytics",
    "keywords": "Sys Admin"
  },
  "docs/Articles/WRPlive/wrplive.html": {
    "href": "docs/Articles/WRPlive/wrplive.html",
    "title": "WRPlive | ARMalytics",
    "keywords": "WRPlive Introduction Docfx is a powerful tool but easy to use for most regular use cases, once you understand the basic concepts. Docfx can be used as a static site generator, but the real value of the tool is in bringing together static documentation pages and .NET API documentation. Docfx supports both C# and VB projects (although currently the output of tool is limited to C# syntax), and relies on the long-established XML comment syntax for C# (and similarly for VB). For example, the following C# code: /// <summary> /// Calculates the age of a person on a certain date based on the supplied date of birth. Takes account of leap years, /// using the convention that someone born on 29th February in a leap year is not legally one year older until 1st March /// of a non-leap year. /// </summary> /// <param name=\"dateOfBirth\">Individual's date of birth.</param> /// <param name=\"date\">Date at which to evaluate age at.</param> /// <returns>Age of the individual in years (as an integer).</returns> /// <remarks>This code is not guaranteed to be correct for non-UK locales, as some countries have skipped certain dates /// within living memory.</remarks> public static int AgeAt(this DateOnly dateOfBirth, DateOnly date) { int age = date.Year - dateOfBirth.Year; return dateOfBirth > date.AddYears(-age) ? --age : age; } can be used to generate output like this: Static documentation pages are prepared using Markdown (slightly enhanced to support specific features). Markdown content can also be injected into the generated API documentation using a feature called 'Overwrites'. Once the API documentation has been parsed from the source code, it is compiled along with the Markdown content into a set of HTML pages which can be published on a website. It is also possible to compile the final output into one or more PDFs for offline use. Docfx is a command-line tool that can be invoked directly, or as a .NET Core CLI tool using the dotnet command, but it can also be invoked from source code using the Docset.Build method in the Docfx namespace. It is configured using a JSON configuration file, docfx.json which has sections for different parts of the build process. Consuming .NET projects The most common use case for processing .NET projects is to specify one or more .csproj files in the docfx.json file: { \"metadata\": [ { \"src\": [ { \"files\": [ \"src/MyProject.Abc/*.csproj\", \"src/MyProject.Xyz/*.csproj\" ], \"src\": \"path/to/csprojs\" } ], \"dest\": \"api\" } ], //... } Although Docfx can build a documentation website in one step, it's helpful to understand the separate steps the tool uses to generate its output. The first step is called the metadata step and can be completed using the following command line: docfx metadata path/to/docfx.json This command reads all the source files specified by the projects listed in docfx.json and searches for XML documentation entries. Note that this step does not use .xml compiler output but rather uses the Roslyn compiler to navigate the supplied codebase. The output of this step is a set of YAML files that are stored in the dest folder specified in docfx.json. Here's an example of the (partial) output from the above code example: ### YamlMime:ManagedReference items: - uid: MyProject.Extensions.DateOnlyExtensions.AgeAt(System.DateOnly,System.DateOnly) commentId: M:MyProject.Extensions.DateOnlyExtensions.AgeAt(System.DateOnly,System.DateOnly) id: AgeAt(System.DateOnly,System.DateOnly) isExtensionMethod: true parent: MyProject.Extensions.DateOnlyExtensions langs: - csharp - vb name: AgeAt(DateOnly, DateOnly) nameWithType: DateOnlyExtensions.AgeAt(DateOnly, DateOnly) fullName: MyProject.Extensions.DateOnlyExtensions.AgeAt(System.DateOnly, System.DateOnly) type: Method source: remote: path: src/MyProject/Extensions/DateOnlyExtensions.cs branch: main repo: https://github.com/MyUser/MyProject.git id: AgeAt path: ../../MyProject/src/MyProject/Extensions/DateOnlyExtensions.cs startLine: 63 assemblies: - MyProject.Common namespace: MyProject.Extensions summary: >- Calculates the age of a person on a certain date based on the supplied date of birth. Takes account of leap years, using the convention that someone born on 29th February in a leap year is not legally one year older until 1st March of a non-leap year. For the most part, it isn't important to know too much about the output of the metadata step, except where you want to make reference to entities from your Markdown content. When doing so, you need to reference the relevant uid from the YAML file. However, as you can see, the uid is the same as the full signature of the entity or method including the namespace. It's also worth knowing that the metadata step generates toc.yml, a table-of-contents file for the input source code, grouped by .NET namespace. This is the only auto-generated table-of-contents file; all other toc.yml must be manually created/edited. Note In additional to using .csproj files for input, it is also possible to generate the intermediate YAML output from compiled .dll (or .exe) and .xml files. See .NET API Docs for further details. Documentation Build Process The next step is called the build step and can be completed using the following command line: docfx build path/to/docfx.json (You can append --serve to this step and Docfx will start a local web server so you can preview the final output.) Internally, there are many parts to this step, but in short, Docfx does the following during the build step: resolve all cross-references convert the YAML content from the metadata step into a structured data format, for passing onto the template engine convert all Markdown content into HTML apply templates and themes Conversion of Markdown to HTML is achieved using the Markdig CommonMark-compliant Markdown processor. Template and theme processing is the one part of Docfx that is not coded in C#; instead the Jint JavaScript interpreter is used to run a set of JavaScript scripts; this approach allows an extra level of customisation of the build process as Docfx provides a way to override the default scripts using the template section of the docfx.json file: { \"build\": { //... \"output\": \"_site\", \"template\": [ \"default\", \"modern\", \"templates/mytemplate\" ] } } In this example, Docfx first searches the templates\\mytemplate folder, then the modern folder, then default folder for each .css or .js file. Note that default and modern templates are included with Docfx and included in the Docfx installation packaged alongside the Docfx executable. (The embedded templates can be exported using the command docfx template export default -o path/for/exported_templates where default is the name of the template being exported. The command docfx template list can be used to list the embedded templates within Docfx.)"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | ARMalytics",
    "keywords": "Getting Started"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | ARMalytics",
    "keywords": "Introduction"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | ARMalytics",
    "keywords": "Welcome Go to the new homepage"
  }
}